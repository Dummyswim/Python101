## Table of Contents

- [Iteration in Python](#iteration-in-python)
    + [Introduction](#introduction)
    + [The `while`-loop](#the-while-loop)
        * [Overview](#overview)
        * [The Syntax](#the-syntax)
        * [Examples](#examples)
    + [The `range` data type](#the-range-data-type)
        * [Overview](#overview-1)
        * [Examples](#examples-1)


## Iteration in Python

### Introduction

Iteration is a basic functionality available in all programming languages. Python is no exception to this. Before I describe the various ways in which you can do iteration, it is important to know what iteration is.


> Iteration is the process of repeating one or more lines of code a certain number of times, so that the lines of code will reevaluate with each repetition.

The above definition is in no way a standard definition, but it gives you the basic idea.

Let's say there is a party at your house. You plan on inviting 20 of your closest friends. As food, you want to serve them some sandwiches, containing mayonnaise, cucumber and tomato with small pinches of salt and pepper. What steps will you follow? Something along these lines:

```text
1. Take two slices of bread
2. Spread mayonnaise on both slices
3. Cut up the cucumber and tomato
4. Place them on any one slice
5. Sprinkle salt and pepper on the slice
6. Place the other slice on top of this slice
7. Give a nice squeeze to the sandwich so that it is firm
8. Repeat steps 1 through 7 till remaining sandwiches are ready
```

Pay attention to the last step in this list. It asks you to repeat the steps 1 through 7. This is because the steps 1 through 7 only result in one sandwich, but you need 20 sandwiches in total (let's assume that you won't eat any sandwiches). Repeating the steps 20 times will give you the 20 sandwiches.


Now, let's build a similar list for some operation involving computation. Let's say you want to list out all squares from 1 to 100. You can do this as follows:  

```text
1. Initialize num = 1
2. Calculate square = num ** 2
3. Print value of square
4. Change num to num + 1
5. Repeat steps 2 through 4 till num = 100
```

This is a very natural set of steps. If you repeat steps 2 through 4, you'll get the squares of all numbers from 1 to 100.

You can visualize the steps as follows:

<p align="center">
    <img src="/img/flow_chart_iteration.png"></img>
</p>

This is the essential idea behind iteration: repetition of the same steps many times. Iteration is also referred to as looping, since you're going to the same point as in a loop.

Now, that's all well and good. For you and me, if I tell you to "repeat" something, you'll understand that I want you to do that thing again. But, how do you tell a programming language that you want it to repeat something? In other words, what is the synonym for the word "repeat" in Python? Well, there are two synonyms: `for`-loop and `while`-loop.


When you write some lines of code in a `for`- or `while`-loop, Python will understand that you want it to repeat those lines of code some number of times.

Let's see how you can write each of these loops.

### The `while`-loop

#### Overview

The `while`-loop is a common loop in most programming languages. It repeats some steps till some condition remains `True`. Once the condition becomes `False`, the loop ends and execution continues after the loop.

Let's say that you are having another party. This time, you do not know how many guests are going to be there, but you want to serve sandwiches to all the guests. What do you do? You keep making sandwiches until all the guests have a sandwich. If you look at the list up above, you'll keep repeating steps 1 through 7 till all guests have a sandwich.

A `while`-loop is like this. You do not know the number of iterations of the loop, but you know that it will repeat till some condition becomes false. For the sandwiches, you do not know how many sandwiches you'll end up making, but know that the process will keep going till all guests have a sandwich.

#### The Syntax

To write a `while`-loop in Python, you use the keyword `while`, followed by a `condition` and a `:` (colon):

```python
while condition:
    # body
```

[As for `if`-statements](/5.0%20Control%20Flow%20Statements/5.1%20The%20if%20Statement.md#the-syntax), the indentation becomes important. Anything that you indent one level after the `while` line is part of the loop and will repeat till `condition` becomes `False`.

A natural question arises. What can `condition` be? It can be any expression that evaluates to `True` or `False`, including entities that considered truthy or falsy. For example, `x < 5` is a valid condition for a `while`-loop.

As a rule of thumb, a condition that you can use in an `if`-statement will also  work in a `while`-loop.

To understand it better, let's look at a few examples.

#### Examples

* **Printing squares of numbers between 1 and 100**:

```python
num = 1
while num <= 100:
    print(num ** 2)
    num += 1
```
Here, `num` is first initialized to `1`. Then, we write the `while`-loop with the condition that it should run only till `num <= 100` . For each iteration of the loop, Python is to print the square and increment `num`'s value by 1. When the value of `num` becomes `101`, Python checks the condition in the `while`-loop, evaluating `101 <= 100`. Since this is `False`, the loop stops.

Take note of the final statement in the loop. It increments the value of `num` by 1 in each iteration. This is essential to making the loop stop. Let's assume that there is no increment. Then, for each iteration, the value of `num` will always be `1` and the condition, `num <= 100` will always evaluate to `True` since `1 <= 100`. This would create an _infinite_ loop which never stops running. In most cases, you don't want an infinite loop and should avoid them.

Thus, the condition of the `while`-loop should involve variables that the body of the loop changes. If the variables remain unchanged in each iteration of the loop, it will become infinite.

Sometimes, though, you might want to write an infinite loop as a need. Python provides you with a neat way of doing that.

* **Making a loop run an infinite number of times**:

```python
while True:
    # do something
```

This is simple and intuitive. Since `True` is `True` in each iteration of the loop, the loop becomes infinite. Later, we'll use this method to generate infinitely long series of numbers, so keep it in mind.

In certain cases, you might want to keep taking input from the user till they decide to stop supplying an input. You can achieve this using a `while`-loop.

* **Taking input from user till they decide to stop**:

```python
repeat = True

while repeat:
    num = input("Enter a number: ")
    print("You entered ", num)
    
    prompt = input("Would you like to enter another number? (Y/N) ")
    if prompt in ('N', 'n'):
        repeat = False
```
We first set a variable `repeat` to `True`. Then, the loop will use the variable as its condition. In the first iteration, since the value of `repeat` will be `True`, the loop will execute. In the final statements of the loop, it will ask the user to decide whether they want to input another number or not. The user can enter `Y` or `y` indicating `yes`, and `N` or `n` indicating `no`. If the user enters `N` or `n`, the value of repeat will change to `False`. When this happens, in the next iteration, when the loop checks the condition again, it will evaluate to `False` and the loop won't execute. The loop will stop taking input.

This is a common use case of `while`-loops. In languages such as `C` or `C++`, you would have done this using a `do-while` loop. This loop runs at least once, irrespective of its condition being `True` or `False` in the first iteration. But, Python does not have those and you'll have to use `while`-loops instead.

Once we're done with `for`-loops, we'll look at a few more examples of `while`-loops.

Before we start with `for`-loops though, we need to to discuss another _built-in data type_ in Python

### The `range` data type

#### Overview

I suppose you know what an [arithmetic progression (AP)](https://en.wikipedia.org/wiki/Arithmetic_progression) is. On a basic level, an AP is a sequence of numbers where the difference between each pair of successive numbers is constant. In other words, if the sequence is something like this,

a<sub>0</sub>, a<sub>1</sub>, a<sub>2</sub>, ..., a<sub>n</sub>,

Then (a<sub>1</sub> - a<sub>0</sub>) = (a<sub>2</sub> - a<sub>1</sub>) = ... = (a<sub>n</sub> - a<sub>n-1</sub>) = constant

This constant is called the _common difference_.

Examples include sequences like `1, 2, 3, 4, 5` and `2, 4, 6, 8, 10`, etc. In the first case, the common difference is `1` and in the second case, the difference is `2`.

`range` is such a sequence of numbers. As far as data types go, it is immutable.

Now, a lot of Python tutorials refer to `range` as a function rather than a data type, but that is not true. `range` _is indeed a data type that you can create using a "function" called `range()`_. This `range()` function is like the `list()` function which you can call to create a list, or like the `dict()` function which you can call to create a dictionary.

Like most other functions, `range()` takes a few arguments. Specifically, it takes three arguments: _start_, _stop_ and _step_. The _start_ argument tells the function where to start the AP. The _stop_ argument tells the function where to end the AP. The _step_ argument tells the function the common difference for the AP.

Thus, you call the function as `range(start, stop, step)`.

There's a catch though. I said that _stop_ tells the function where to end the AP. That's not entirely true. While the _stop_ argument does set an upper bound on the AP, _stop_ is never actually included in the AP. The AP is always inclusive of _start_ and exclusive of _stop_.

As a result, given _start_, _stop_ and _step_, the `range()` function will produce an AP where:

```
First-term = start
Common difference = step
Last-term = stop - step
```

Let's look at a few examples.

#### Examples

* **All even number from 2 to 100**:
 
```python
>>> even = range(2, 101, 2)
>>> even
range(2, 101, 2)
```

Since the sequence should start at `2`, the _start_ argument is `2`. We want even numbers from `2`. If we start counting from `2`, every even number will be 2 more than the previous even number. For example, the next even number, `4` is `2 + 2` and the one after that, `6` is `4 + 2`. Thus, the _step_ argument is `2`.

Though we need even numbers up to 100, the _stop_ argument is `101`. This is because _stop_ is never included in the AP. If _stop_ was _100_, the AP would go till `100 - 2 = 98` and miss `100`. By setting it to `101`, we ensure the result will have `100` in it.

Take note of how entering `even` in the Python prompt does not show you the entire sequence. It confusingly looks like the function you called. This has to do with how `range` is implemented in Python. We'll discuss that later. For now, know that to view the entire sequence, you need to convert `range` to some other sequence like a list or a tuple:

```python
>>> list(even)
[2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100]
```

* **All odd numbers from 1 to 100**:

```python
>>> odd = range(1, 101, 2)
>>> odd
range(1, 101, 2)
>>> list(odd)
[1, 3, 5, ..., 97, 99]
```
> Note: Ellipses (...) used to shorten output. Actual output is much larger than this.
> 
* **All multiples of 3 from 6 to 100**:

```python
>>> multiples_3 = range(6, 100, 3)
>>> multiples_3
range(3, 100, 3)
>>> list(multiples_3)
[6, 9, 12, ..., 96, 99]
```

It is not always necessary to mention the _step_ argument. In such cases, Python assumes the _step_ to be `1` so that the AP's common difference in `1`.

* **All natural numbers between 1 to 100**:

```python
>>> natural_100 = range(1, 101)
>>> natural_100
range(1, 101)
>>> list(natural_100)
[1, 2, 3, ..., 99, 100]
```

You might think that you're storing 100 numbers through `range`. It must take a lot of memory. But, it doesn't. You can efficiently store thousands of numbers in this without worrying about memory. We'll discuss why that is the case later.

You can even omit the _start_ argument with the _step_. You call the function with one argument, _stop_. In such a case, the AP starts at `0` with a common difference of `1`, ending at `stop - 1`.

* **All whole numbers up to 100**:

```python
>>> whole_100 = range(101)
>>> whole_100
range(0, 100)
>>> list(whole_100)
[0, 1, 2, ..., 99, 100]
```

You can use this to get the indices of a list, tuple or string. In Python, the indexing for a list starts at `0` and ends at one less than its length. For example, for the list, `[1, 2, 3, 4]`, the indices are `0, 1, 2, 3`. Thus, by the very nature of `range`, you can use it to get the indices of such sequences.

* **Indices of a list**:

```python
>>> l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
>>> length = len(l)
>>> indices = range(length)
>>> indices
range(0, 10)
>>> list(indices)
[0, 1, ...., 8, 9]
```

Since there are no _start_ and _step_ arguments, they default to `0` and `1` respectively. The length of the list is the _stop_ argument. As a result, the AP will go from 0 to `length - 1`, which are the indices of the items in the list.

**The `range` data type only works with integers. If at least one of its arguments is not an integer, it will give you an error**:

```python
>>> wrong_range = range(10.5)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'float' object cannot be interpreted as an integer
```

**Since it accepts integers, you can use it with negative numbers**:

```python
>>> negative_range = range(-10, 11)
>>> list(negative_range)
[-10, -9, -8, ..., 9, 10]
```

**You can specifically mention the _step_ to be the negative**. In such a case, the _start_ needs to be greater than the _stop_:

```python
>>> reverse_range = range(10, 0, -1)
>>> list(reverse_range)
[10, 9, ..., 2, 1]
```

### The `for`-loop

The `for`-loop is another common loop in most programming language. There's a fundamental difference between `for`- and `while`-loops. As was discussed, in a `while`-loop, you never know how many 
